#!/usr/bin/env cbqn
# summarize a CSV file generated by `benchm`
# Usage: parse.bqn generated.csv
csv ← {
  # Control characters: double quote, comma, newline
  control ← ""","∾@+10
  # Join by separator 𝕨
  J ← ∾1↓·⥊<⊸(≍˘)
  # CSV text to list of list of strings
  Split ← { 𝕊⁼𝕩: Join𝕩 ;
   [q,c,n] ← control=⌜𝕩
   e ← ≠`q       # Escaped characters
   s ← e<c∨n     # Split points
   d ← s∨q>»e<q  # Characters to be dropped
   (0∾s/+`e<n) ⊔ (d(¬⊸×-⊣)+`s) ⊔ 𝕩
  }
  # Parse list of lines, e.g. from •file.Lines
  SplitL ← { 𝕊⁼𝕩: JoinL𝕩 ; Split (2⊑control) J 𝕩 }
  # List of list of strings, or table, to list of lines
  # Result contains internal line separators if 𝕩 does
  JoinL ← { 𝕊⁼𝕩: SplitL𝕩 ;
    q‿c‿n ← control
    𝕩 <˘⍟(1<=)↩
    Esc ← (q∾˜q∾(1+q⊸=)⊸/)⍟(∨´control⊸∊)
    (c J Esc¨)¨ 𝕩
  }
  # To CSV text
  Join ← { 𝕊⁼𝕩: Split𝕩 ; (2⊑control) J JoinL 𝕩 }
  NoValueField ← (⟨1,1⟩⊸≡)¨∘<˘2↕·(','⊸≡)¨(','⊸(∾˜))
  RelativePath ← { '/'=⊑𝕩 ? 𝕩; •wdpath∾ "/"∾ 𝕩 }
  ParseFile ⇐ {
  ((@⊸≠)¨⊸/)¨¨˘·SplitL (∾NoValueField⊸({𝕨 ? ⟨',',@⟩;⟨𝕩⟩}¨))¨ ('#'⊸≢⊑)¨⊸/•Flines RelativePath 𝕩;
  ((@⊸≢)¨⊸/)¨¨˘·SplitL (∾NoValueField⊸({𝕨 ? ⟨',',@⟩;⟨𝕩⟩}¨))¨ 𝕨↓('#'⊸≢⊑)¨⊸/•Flines RelativePath 𝕩
  }
}
color ← {
  esc ⇐ @ + 27
  csi ⇐ esc∾"["
  reset ⇐ csi∾"0m"
  RGB ⇐ {
      𝕊 r‿g‿b: esc∾"[38;2;"∾(•Fmt r)∾";"∾(•Fmt g)∾";"∾(•Fmt b)∾"m";
    0 𝕊 r‿g‿b: esc∾"[38;2;"∾(•Fmt r)∾";"∾(•Fmt g)∾";"∾(•Fmt b)∾"m";
    r‿g‿b 𝕊 0: esc∾"[48;2;"∾(•Fmt r)∾";"∾(•Fmt g)∾";"∾(•Fmt b)∾"m";
    bg 𝕊 fg: (bg 𝕊 0)∾𝕊 fg
  }
  Out ⇐ { c 𝕊 t: c∾t∾reset }
  Fmt ⇐ { c 𝕊 t: c∾(•Fmt t)∾reset }
}

Colored ← {
 𝕊 n‿no‿name‿time‿0: ⟨color.RGB 240‿20‿100⟩∾(¯1↓𝕩)∾⟨color.reset⟩;
 𝕊 n‿no‿name‿time‿1: ⟨color.RGB 20‿180‿120⟩∾(¯1↓𝕩)∾⟨color.reset⟩
}
Replace ← {⊑𝕩∊𝕨 ? ' ';𝕩}
Sat ← { 𝕊 "": ∞;𝕊 "false": 0; 𝕊 "true": 1}
solved ⇐ (∞⊸≠4⊸⊑)˘⊸/{⟨•BQN 3⊑𝕩,•BQN 1⊑𝕩,66(<⟜≠)◶⟨⊢,↑⟩2⊑𝕩,•ParseFloat 4⊑𝕩,Sat 6⊑𝕩⟩}˘((≠⋈(≠⊑))⥊∾´) 1 csv.ParseFile ⊑•args
•Out ("┌─╵┘"""⊸Replace)¨•Fmt Colored˘ solved
